<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>WebSocket API</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../_static/epub.css?v=1d6d279e" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=3afbad45" />
    <link rel="stylesheet" type="text/css" href="../_static/interactive.css?v=267755d7" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="websocket-api">
<h1>WebSocket API</h1>
<p>The ProvChainOrg WebSocket API provides real-time communication for blockchain events, peer discovery, and live data updates. This API enables building responsive applications that can react immediately to blockchain changes.</p>
<section id="overview">
<h2>Overview</h2>
<p>The WebSocket API supports:</p>
<ul class="simple">
<li><p><strong>Real-time Block Updates</strong> - Instant notifications for new blocks</p></li>
<li><p><strong>Peer Discovery</strong> - Dynamic peer connection management</p></li>
<li><p><strong>Live Query Results</strong> - Streaming query results as they change</p></li>
<li><p><strong>Event Subscriptions</strong> - Subscribe to specific blockchain events</p></li>
<li><p><strong>Bidirectional Communication</strong> - Send commands and receive responses</p></li>
</ul>
</section>
<section id="connection">
<h2>Connection</h2>
<p><strong>WebSocket URL:</strong> <code class="docutils literal notranslate"><span class="pre">ws://localhost:8080/ws</span></code></p>
<p><strong>Authentication:</strong>
Connect with API key query parameter:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">ws://localhost:8080/ws?api_key=YOUR_API_KEY</span>
<span class="pre">`</span></code></p>
<p><strong>Connection Example:</strong>
<a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>javascript
const ws = new WebSocket(‘ws://localhost:8080/ws?api_key=YOUR_API_KEY’);</p>
<dl class="simple">
<dt>ws.onopen = () =&gt; {</dt><dd><p>console.log(‘Connected to ProvChainOrg WebSocket’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>ws.onmessage = (event) =&gt; {</dt><dd><p>const message = JSON.parse(event.data);
console.log(‘Received message:’, message);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>ws.onclose = () =&gt; {</dt><dd><p>console.log(‘WebSocket connection closed’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>ws.onerror = (error) =&gt; {</dt><dd><p>console.error(‘WebSocket error:’, error);</p>
</dd>
</dl>
<section id="id5">
<h3>};</h3>
</section>
</section>
<section id="message-format">
<h2>Message Format</h2>
<p>All WebSocket messages follow this JSON structure:</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “message_type”,
“id”: “unique_message_id”,
“timestamp”: “2025-01-14T18:30:00Z”,
“data”: {},
“error”: null</p>
</div></blockquote>
<section id="id10">
<h3>}</h3>
</section>
</section>
<section id="message-types">
<h2>Message Types</h2>
<p><strong>New Block Notification</strong>
Sent when a new block is added to the blockchain.</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “new_block”,
“data”: {</p>
<blockquote>
<div><p>“index”: 43,
“timestamp”: “2025-01-14T18:30:15Z”,
“hash”: “0x8f3e2d1c9b8a7654…”,
“previous_hash”: “0x4a7b2c8f9e1d3a5b…”,
“triple_count”: 15,
“graph_name”: “<a class="reference external" href="http://provchain.org/block/43">http://provchain.org/block/43</a>”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<section id="id15">
<h3>}</h3>
<p><strong>Block Validation Result</strong>
Sent when a block validation completes.</p>
<p><a href="#id16"><span class="problematic" id="id17">``</span></a><a href="#id18"><span class="problematic" id="id19">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “block_validation”,
“data”: {</p>
<blockquote>
<div><p>“block_index”: 43,
“is_valid”: true,
“validation_time_ms”: 245,
“issues”: []</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id20">
<h3>}</h3>
<section id="network-events">
<h4>Network Events</h4>
<p><strong>Peer Connected</strong>
Notification when a new peer connects.</p>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “peer_connected”,
“data”: {</p>
<blockquote>
<div><p>“peer_id”: “peer-001”,
“address”: “192.168.1.100:8080”,
“connection_time”: “2025-01-14T18:28:00Z”,
“capabilities”: [“query”, “block_sync”]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id25">
<h3>}</h3>
<p><strong>Peer Disconnected</strong>
Notification when a peer disconnects.</p>
<p><a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “peer_disconnected”,
“data”: {</p>
<blockquote>
<div><p>“peer_id”: “peer-001”,
“address”: “192.168.1.100:8080”,
“disconnection_time”: “2025-01-14T18:35:00Z”,
“reason”: “normal_closure”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id30">
<h3>}</h3>
<section id="query-events">
<h4>Query Events</h4>
<p><strong>Query Started</strong>
Notification when a query execution begins.</p>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “query_started”,
“data”: {</p>
<blockquote>
<div><p>“query_id”: “query_123456789”,
“sparql_query”: “SELECT ?batch ?product WHERE { ?batch a :ProductBatch ; :product ?product }”,
“started_at”: “2025-01-14T18:30:00Z”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id35">
<h3>}</h3>
<p><strong>Query Progress</strong>
Streaming updates for long-running queries.</p>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “query_progress”,
“data”: {</p>
<blockquote>
<div><p>“query_id”: “query_123456789”,
“progress”: 45,
“current_result_count”: 150,
“estimated_completion”: “2025-01-14T18:30:15Z”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id40">
<h3>}</h3>
<p><strong>Query Completed</strong>
Final result when query execution completes.</p>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “query_completed”,
“data”: {</p>
<blockquote>
<div><p>“query_id”: “query_123456789”,
“result_count”: 324,
“execution_time_ms”: 1250,
“results”: [</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>“batch”: “<a class="reference external" href="http://example.org/supply-chain#Batch001">http://example.org/supply-chain#Batch001</a>”,
“product”: “<a class="reference external" href="http://example.org/supply-chain#OrganicTomatoes">http://example.org/supply-chain#OrganicTomatoes</a>”</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id45">
<h3>}</h3>
<section id="error-events">
<h4>Error Events</h4>
<p><strong>Connection Error</strong>
WebSocket connection errors.</p>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “connection_error”,
“data”: {</p>
<blockquote>
<div><p>“error_code”: “AUTHENTICATION_FAILED”,
“message”: “Invalid API key provided”,
“retry_after”: 30</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id50">
<h3>}</h3>
<p><strong>Validation Error</strong>
Data validation errors.</p>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “validation_error”,
“data”: {</p>
<blockquote>
<div><p>“error_code”: “INVALID_RDF_DATA”,
“message”: “Malformed Turtle syntax”,
“details”: {</p>
<blockquote>
<div><p>“line”: 5,
“column”: 12,
“expected”: “property URI”,
“found”: “invalid_token”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id55">
<h3>}</h3>
</section>
</section>
<section id="client-commands">
<h2>Client Commands</h2>
<p>Subscribe to specific event types.</p>
<p><strong>Command:</strong>
<a href="#id56"><span class="problematic" id="id57">``</span></a><a href="#id58"><span class="problematic" id="id59">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “subscribe”,
“command”: {</p>
<blockquote>
<div><p>“events”: [“new_block”, “peer_connected”, “query_completed”],
“filters”: {</p>
<blockquote>
<div><p>“block_index_min”: 40</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<section id="id60">
<h3>}</h3>
<p><strong>Response:</strong>
<a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “subscription_ack”,
“data”: {</p>
<blockquote>
<div><p>“subscription_id”: “sub_123456789”,
“events”: [“new_block”, “peer_connected”, “query_completed”],
“active”: true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id65">
<h3>}</h3>
<section id="unsubscribe-from-events">
<h4>Unsubscribe from Events</h4>
<p>Cancel event subscriptions.</p>
<p><strong>Command:</strong>
<a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “unsubscribe”,
“command”: {</p>
<blockquote>
<div><p>“subscription_id”: “sub_123456789”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id70">
<h3>}</h3>
<section id="execute-query">
<h4>Execute Query</h4>
<p>Execute a SPARQL query with streaming results.</p>
<p><strong>Command:</strong>
<a href="#id71"><span class="problematic" id="id72">``</span></a><a href="#id73"><span class="problematic" id="id74">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “execute_query”,
“command”: {</p>
<blockquote>
<div><p>“sparql_query”: “SELECT ?batch ?product WHERE { ?batch a :ProductBatch ; :product ?product }”,
“stream_results”: true,
“batch_size”: 100</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id75">
<h3>}</h3>
<p><strong>Response:</strong>
<a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “query_started”,
“data”: {</p>
<blockquote>
<div><p>“query_id”: “query_123456789”,
“sparql_query”: “SELECT ?batch ?product WHERE { ?batch a :ProductBatch ; :product ?product }”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id80">
<h3>}</h3>
<p><strong>Streaming Results:</strong>
<a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “query_results”,
“data”: {</p>
<blockquote>
<div><p>“query_id”: “query_123456789”,
“batch_number”: 1,
“results”: [</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>“batch”: “<a class="reference external" href="http://example.org/supply-chain#Batch001">http://example.org/supply-chain#Batch001</a>”,
“product”: “<a class="reference external" href="http://example.org/supply-chain#OrganicTomatoes">http://example.org/supply-chain#OrganicTomatoes</a>”</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id85">
<h3>}</h3>
<section id="add-rdf-data">
<h4>Add RDF Data</h4>
<p>Add new RDF data through WebSocket.</p>
<p><strong>Command:</strong>
<a href="#id86"><span class="problematic" id="id87">``</span></a><a href="#id88"><span class="problematic" id="id89">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “add_rdf_data”,
“command”: {</p>
<blockquote>
<div><p>“turtle_data”: “&#64;prefix : &lt;<a class="reference external" href="http://example.org/supply">http://example.org/supply</a>-chain#&gt; .n:Batch001 a :ProductBatch ; :hasBatchID &quot;TEST-001&quot; .”,
“validate”: true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id90">
<h3>}</h3>
<p><strong>Response:</strong>
<a href="#id91"><span class="problematic" id="id92">``</span></a><a href="#id93"><span class="problematic" id="id94">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “add_rdf_data_response”,
“data”: {</p>
<blockquote>
<div><p>“block_index”: 44,
“hash”: “0x1a2b3c4d5e6f7890…”,
“validation_passed”: true</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id95">
<h3>}</h3>
<section id="request-blockchain-status">
<h4>Request Blockchain Status</h4>
<p>Get current blockchain status.</p>
<p><strong>Command:</strong>
<a href="#id96"><span class="problematic" id="id97">``</span></a><a href="#id98"><span class="problematic" id="id99">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “get_status”,
“command”: {}</p>
</div></blockquote>
</section>
</section>
<section id="id100">
<h3>}</h3>
<p><strong>Response:</strong>
<a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “status_response”,
“data”: {</p>
<blockquote>
<div><dl class="simple">
<dt>“blockchain”: {</dt><dd><p>“current_height”: 43,
“latest_block_hash”: “0x4a7b2c8f9e1d3a5b…”,
“total_transactions”: 156</p>
</dd>
</dl>
<p>},
“rdf_store”: {</p>
<blockquote>
<div><p>“total_triples”: 1247,
“named_graphs”: 43</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id105">
<h3>}</h3>
<section id="peer-management">
<h4>Peer Management</h4>
<p>Get connected peers.</p>
<p><strong>Command:</strong>
<a href="#id106"><span class="problematic" id="id107">``</span></a><a href="#id108"><span class="problematic" id="id109">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “get_peers”,
“command”: {}</p>
</div></blockquote>
</section>
</section>
<section id="id110">
<h3>}</h3>
<p><strong>Response:</strong>
<a href="#id111"><span class="problematic" id="id112">``</span></a><a href="#id113"><span class="problematic" id="id114">`</span></a>json
{</p>
<blockquote>
<div><p>“type”: “peers_response”,
“data”: {</p>
<blockquote>
<div><dl>
<dt>“connected_peers”: [</dt><dd><dl class="simple">
<dt>{</dt><dd><p>“id”: “peer-001”,
“address”: “192.168.1.100:8080”,
“last_seen”: “2025-01-14T18:28:00Z”,
“capabilities”: [“query”, “block_sync”]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id115">
<h3>}</h3>
</section>
</section>
<section id="connection-management">
<h2>Connection Management</h2>
<p>Implement automatic reconnection with exponential backoff.</p>
<p><a href="#id116"><span class="problematic" id="id117">``</span></a><a href="#id118"><span class="problematic" id="id119">`</span></a>javascript
class ProvChainWebSocket {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.reconnectAttempts = 0;
this.maxReconnectAttempts = 5;
this.reconnectDelay = 1000;
this.subscriptions = new Set();
this.messageHandlers = new Map();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>connect() {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘WebSocket connected’);
this.reconnectAttempts = 0;
this.resubscribe();</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>const message = JSON.parse(event.data);
this.handleMessage(message);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onclose = () =&gt; {</dt><dd><p>console.log(‘WebSocket disconnected’);
this.scheduleReconnect();</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onerror = (error) =&gt; {</dt><dd><p>console.error(‘WebSocket error:’, error);</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>scheduleReconnect() {</dt><dd><dl>
<dt>if (this.reconnectAttempts &lt; this.maxReconnectAttempts) {</dt><dd><p>const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts);
console.log(<cite>Reconnecting in ${delay}ms…</cite>);</p>
<dl class="simple">
<dt>setTimeout(() =&gt; {</dt><dd><p>this.reconnectAttempts++;
this.connect();</p>
</dd>
</dl>
<p>}, delay);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>resubscribe() {</dt><dd><dl>
<dt>this.subscriptions.forEach(subscription =&gt; {</dt><dd><dl class="simple">
<dt>this.send({</dt><dd><p>type: ‘subscribe’,
command: subscription</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleMessage(message) {</dt><dd><p>const handler = this.messageHandlers.get(message.type);
if (handler) {</p>
<blockquote>
<div><p>handler(message);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>send(message) {</dt><dd><dl class="simple">
<dt>if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {</dt><dd><p>this.ws.send(JSON.stringify(message));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>subscribe(events, filters = {}) {</dt><dd><p>const subscription = { events, filters };
this.subscriptions.add(subscription);</p>
<dl class="simple">
<dt>this.send({</dt><dd><p>type: ‘subscribe’,
command: subscription</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>unsubscribe(subscriptionId) {</dt><dd><dl class="simple">
<dt>this.subscriptions = new Set([…this.subscriptions].filter(</dt><dd><p>sub =&gt; sub.id !== subscriptionId</p>
</dd>
</dl>
<p>));</p>
<dl class="simple">
<dt>this.send({</dt><dd><p>type: ‘unsubscribe’,
command: { subscription_id: subscriptionId }</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>onMessage(messageType, handler) {</dt><dd><p>this.messageHandlers.set(messageType, handler);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Usage
const wsClient = new ProvChainWebSocket(‘ws://localhost:8080/ws’, ‘YOUR_API_KEY’);</p>
<p>wsClient.connect();</p>
<p>// Subscribe to events
wsClient.subscribe([‘new_block’, ‘query_completed’]);</p>
<p>// Handle specific message types
wsClient.onMessage(‘new_block’, (message) =&gt; {</p>
<blockquote>
<div><p>console.log(‘New block:’, message.data);</p>
</div></blockquote>
<p>});</p>
<dl class="simple">
<dt>wsClient.onMessage(‘query_completed’, (message) =&gt; {</dt><dd><p>console.log(‘Query completed with’, message.data.result_count, ‘results’);</p>
</dd>
</dl>
<section id="id120">
<h3>});</h3>
<section id="message-ordering">
<h4>Message Ordering</h4>
<p>Ensure proper message ordering with sequence numbers.</p>
<p><a href="#id121"><span class="problematic" id="id122">``</span></a><a href="#id123"><span class="problematic" id="id124">`</span></a>javascript
class OrderedWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.expectedSequence = 1;
this.messageQueue = new Map();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>connect() {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl>
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>const message = JSON.parse(event.data);
if (message.sequence !== undefined) {</p>
<blockquote>
<div><p>this.handleSequencedMessage(message);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>this.handleMessage(message);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleSequencedMessage(message) {</dt><dd><dl class="simple">
<dt>if (message.sequence === this.expectedSequence) {</dt><dd><p>this.handleMessage(message);
this.expectedSequence++;
this.processQueue();</p>
</dd>
<dt>} else {</dt><dd><p>this.messageQueue.set(message.sequence, message);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>processQueue() {</dt><dd><dl class="simple">
<dt>while (this.messageQueue.has(this.expectedSequence)) {</dt><dd><p>const message = this.messageQueue.get(this.expectedSequence);
this.handleMessage(message);
this.messageQueue.delete(this.expectedSequence);
this.expectedSequence++;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleMessage(message) {</dt><dd><p>// Process message in correct order
console.log(‘Processing message:’, message.type, ‘at sequence’, message.sequence);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id125">
<h3>}</h3>
</section>
</section>
<section id="error-handling">
<h2>Error Handling</h2>
<p>Handle various connection error scenarios.</p>
<p><a href="#id126"><span class="problematic" id="id127">``</span></a><a href="#id128"><span class="problematic" id="id129">`</span></a>javascript
class RobustWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.connectionState = ‘disconnected’;
this.retryCount = 0;
this.maxRetries = 5;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>connect() {</dt><dd><dl>
<dt>try {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);
this.connectionState = ‘connecting’;</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>this.connectionState = ‘connected’;
this.retryCount = 0;
console.log(‘WebSocket connected’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onclose = (event) =&gt; {</dt><dd><p>this.connectionState = ‘disconnected’;
this.handleDisconnection(event);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onerror = (error) =&gt; {</dt><dd><p>this.connectionState = ‘error’;
this.handleError(error);</p>
</dd>
</dl>
<p>};</p>
</dd>
<dt>} catch (error) {</dt><dd><p>this.handleConnectionError(error);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleDisconnection(event) {</dt><dd><p>console.log(‘WebSocket disconnected:’, event.code, event.reason);</p>
<dl class="simple">
<dt>if (event.code === 1008) { // Policy violation</dt><dd><p>console.error(‘Authentication failed’);
this.handleAuthenticationError();</p>
</dd>
<dt>} else if (event.code === 1006) { // Abnormal closure</dt><dd><p>console.warn(‘Abnormal closure, attempting reconnect’);
this.scheduleReconnect();</p>
</dd>
<dt>} else {</dt><dd><p>this.scheduleReconnect();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleError(error) {</dt><dd><p>console.error(‘WebSocket error:’, error);</p>
<dl class="simple">
<dt>if (this.retryCount &lt; this.maxRetries) {</dt><dd><p>this.scheduleReconnect();</p>
</dd>
<dt>} else {</dt><dd><p>console.error(‘Max retry attempts reached’);
this.handlePermanentFailure();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleConnectionError(error) {</dt><dd><p>console.error(‘Connection error:’, error);
this.scheduleReconnect();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>scheduleReconnect() {</dt><dd><p>const delay = Math.min(1000 * Math.pow(2, this.retryCount), 30000);
console.log(<cite>Scheduling reconnect in ${delay}ms…</cite>);</p>
<dl class="simple">
<dt>setTimeout(() =&gt; {</dt><dd><p>this.retryCount++;
this.connect();</p>
</dd>
</dl>
<p>}, delay);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleAuthenticationError() {</dt><dd><p>console.error(‘Authentication failed. Please check your API key.’);
// Notify user or refresh authentication</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handlePermanentFailure() {</dt><dd><p>console.error(‘Permanent connection failure’);
// Implement fallback or notify user</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<section id="id130">
<h3>}</h3>
</section>
</section>
<section id="performance-optimization">
<h2>Performance Optimization</h2>
<p>Batch multiple messages for better performance.</p>
<p><a href="#id131"><span class="problematic" id="id132">``</span></a><a href="#id133"><span class="problematic" id="id134">`</span></a>javascript
class BatchedWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.messageQueue = [];
this.batchTimer = null;
this.batchSize = 10;
this.batchInterval = 100; // ms</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>connect() {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘WebSocket connected’);
this.startBatching();</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>this.handleMessage(JSON.parse(event.data));</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>startBatching() {</dt><dd><dl>
<dt>this.batchTimer = setInterval(() =&gt; {</dt><dd><dl class="simple">
<dt>if (this.messageQueue.length &gt; 0) {</dt><dd><p>this.flushBatch();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}, this.batchInterval);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>send(message) {</dt><dd><p>this.messageQueue.push(message);</p>
<dl class="simple">
<dt>if (this.messageQueue.length &gt;= this.batchSize) {</dt><dd><p>this.flushBatch();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>flushBatch() {</dt><dd><p>if (this.messageQueue.length === 0) return;</p>
<p>const batch = this.messageQueue.splice(0, this.batchSize);
const batchMessage = {</p>
<blockquote>
<div><p>type: ‘batch’,
messages: batch</p>
</div></blockquote>
<p>};</p>
<dl class="simple">
<dt>if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {</dt><dd><p>this.ws.send(JSON.stringify(batchMessage));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleMessage(message) {</dt><dd><dl class="simple">
<dt>if (message.type === ‘batch_response’) {</dt><dd><p>message.messages.forEach(msg =&gt; this.processMessage(msg));</p>
</dd>
<dt>} else {</dt><dd><p>this.processMessage(message);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>processMessage(message) {</dt><dd><p>// Process individual message
console.log(‘Processed message:’, message.type);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<section id="id135">
<h3>}</h3>
<section id="compression">
<h4>Compression</h4>
<p>Implement message compression for large data transfers.</p>
<p><a href="#id136"><span class="problematic" id="id137">``</span></a><a href="#id138"><span class="problematic" id="id139">`</span></a>javascript
class CompressedWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.compressionEnabled = true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>connect() {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘WebSocket connected’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>const message = this.decompressMessage(event.data);
this.handleMessage(message);</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>send(message) {</dt><dd><p>const messageString = JSON.stringify(message);
const compressedData = this.compressMessage(messageString);</p>
<dl class="simple">
<dt>if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {</dt><dd><p>this.ws.send(compressedData);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>compressMessage(data) {</dt><dd><dl class="simple">
<dt>if (!this.compressionEnabled) {</dt><dd><p>return data;</p>
</dd>
</dl>
<p>}</p>
<p>// Implement compression (e.g., using pako or similar library)
// For demonstration, we’ll just return the original data
return data;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>decompressMessage(data) {</dt><dd><dl class="simple">
<dt>if (!this.compressionEnabled) {</dt><dd><p>return JSON.parse(data);</p>
</dd>
</dl>
<p>}</p>
<p>// Implement decompression
return JSON.parse(data);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleMessage(message) {</dt><dd><p>console.log(‘Received compressed message:’, message.type);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id140">
<h3>}</h3>
</section>
</section>
<section id="security-considerations">
<h2>Security Considerations</h2>
<p>Implement secure authentication mechanisms.</p>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a>javascript
class SecureWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.authToken = null;
this.refreshToken = null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>async connect() {</dt><dd><dl>
<dt>try {</dt><dd><p>// First, authenticate to get a WebSocket token
const authResponse = await this.authenticate();
this.authToken = authResponse.token;
this.refreshToken = authResponse.refresh_token;</p>
<p>// Connect with the token
const wsUrl = <cite>${this.url}?token=${this.authToken}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘Secure WebSocket connected’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onclose = () =&gt; {</dt><dd><p>this.handleDisconnection();</p>
</dd>
</dl>
<p>};</p>
</dd>
<dt>} catch (error) {</dt><dd><p>console.error(‘Authentication failed:’, error);
this.handleAuthenticationError(error);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>async authenticate() {</dt><dd><dl>
<dt>const response = await fetch(<cite>${this.url.replace(‘/ws’, ‘/auth’)}</cite>, {</dt><dd><p>method: ‘POST’,
headers: {</p>
<blockquote>
<div><p>‘Content-Type’: ‘application/json’,
‘Authorization’: <cite>Bearer ${this.apiKey}</cite></p>
</div></blockquote>
<p>},
body: JSON.stringify({</p>
<blockquote>
<div><p>grant_type: ‘client_credentials’,
scope: ‘websocket’</p>
</div></blockquote>
<p>})</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>if (!response.ok) {</dt><dd><p>throw new Error(‘Authentication failed’);</p>
</dd>
</dl>
<p>}</p>
<p>return response.json();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>async refreshToken() {</dt><dd><dl>
<dt>try {</dt><dd><dl>
<dt>const response = await fetch(<cite>${this.url.replace(‘/ws’, ‘/auth’)}</cite>, {</dt><dd><p>method: ‘POST’,
headers: {</p>
<blockquote>
<div><p>‘Content-Type’: ‘application/json’,
‘Authorization’: <cite>Bearer ${this.refreshToken}</cite></p>
</div></blockquote>
<p>},
body: JSON.stringify({</p>
<blockquote>
<div><p>grant_type: ‘refresh_token’</p>
</div></blockquote>
<p>})</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>if (response.ok) {</dt><dd><p>const authData = await response.json();
this.authToken = authData.token;
return true;</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} catch (error) {</dt><dd><p>console.error(‘Token refresh failed:’, error);</p>
</dd>
</dl>
<p>}
return false;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleDisconnection() {</dt><dd><p>// Attempt to reconnect with refreshed token
this.connect();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleAuthenticationError(error) {</dt><dd><p>console.error(‘Authentication error:’, error);
// Implement proper error handling and user notification</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<section id="id145">
<h3>}</h3>
<section id="message-encryption">
<h4>Message Encryption</h4>
<p>Implement end-to-end encryption for sensitive messages.</p>
<p><a href="#id146"><span class="problematic" id="id147">``</span></a><a href="#id148"><span class="problematic" id="id149">`</span></a>javascript
class EncryptedWebSocketClient {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(url, apiKey) {</dt><dd><p>this.url = url;
this.apiKey = apiKey;
this.ws = null;
this.encryptionKey = null;
this.keyExchangeComplete = false;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>async connect() {</dt><dd><p>const wsUrl = <cite>${this.url}?api_key=${this.apiKey}</cite>;
this.ws = new WebSocket(wsUrl);</p>
<dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘WebSocket connected, initiating key exchange’);
this.initiateKeyExchange();</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>this.handleEncryptedMessage(event.data);</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>async initiateKeyExchange() {</dt><dd><p>// Generate ephemeral key pair
const ephemeralKey = this.generateEphemeralKey();</p>
<p>// Send key exchange request
const keyExchangeMessage = {</p>
<blockquote>
<div><p>type: ‘key_exchange’,
public_key: ephemeralKey.publicKey</p>
</div></blockquote>
<p>};</p>
<p>this.send(keyExchangeMessage);</p>
<p>// Wait for server response
// In a real implementation, this would be more sophisticated
this.encryptionKey = await this.deriveSharedKey(ephemeralKey);
this.keyExchangeComplete = true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>generateEphemeralKey() {</dt><dd><p>// Implement key generation (e.g., using Web Crypto API)
return {</p>
<blockquote>
<div><p>publicKey: ‘generated_public_key’,
privateKey: ‘generated_private_key’</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>async deriveSharedKey(ephemeralKey) {</dt><dd><p>// Implement key derivation
return ‘derived_shared_key’;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>encryptMessage(message) {</dt><dd><dl class="simple">
<dt>if (!this.keyExchangeComplete) {</dt><dd><p>return message;</p>
</dd>
</dl>
<p>}</p>
<p>// Implement message encryption
// For demonstration, return original message
return message;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>decryptMessage(encryptedData) {</dt><dd><dl class="simple">
<dt>if (!this.keyExchangeComplete) {</dt><dd><p>return JSON.parse(encryptedData);</p>
</dd>
</dl>
<p>}</p>
<p>// Implement message decryption
return JSON.parse(encryptedData);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>send(message) {</dt><dd><p>const encryptedMessage = this.encryptMessage(JSON.stringify(message));</p>
<dl class="simple">
<dt>if (this.ws &amp;&amp; this.ws.readyState === WebSocket.OPEN) {</dt><dd><p>this.ws.send(encryptedMessage);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleEncryptedMessage(encryptedData) {</dt><dd><p>const message = this.decryptMessage(encryptedData);
this.handleMessage(message);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleMessage(message) {</dt><dd><p>console.log(‘Received encrypted message:’, message.type);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
</section>
<section id="id150">
<h3>}</h3>
</section>
</section>
<section id="example-applications">
<h2>Example Applications</h2>
<p><a href="#id151"><span class="problematic" id="id152">``</span></a><a href="#id153"><span class="problematic" id="id154">`</span></a>javascript
class ProvChainDashboard {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor() {</dt><dd><p>this.ws = new WebSocket(‘ws://localhost:8080/ws?api_key=YOUR_API_KEY’);
this.dashboardElement = document.getElementById(‘dashboard’);
this.setupEventHandlers();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>setupEventHandlers() {</dt><dd><dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘Dashboard connected’);
this.subscribeToEvents();</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>const message = JSON.parse(event.data);
this.handleMessage(message);</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>subscribeToEvents() {</dt><dd><dl>
<dt>this.ws.send(JSON.stringify({</dt><dd><p>type: ‘subscribe’,
command: {</p>
<blockquote>
<div><p>events: [‘new_block’, ‘query_completed’, ‘peer_connected’]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleMessage(message) {</dt><dd><dl class="simple">
<dt>switch (message.type) {</dt><dd><dl class="simple">
<dt>case ‘new_block’:</dt><dd><p>this.updateBlockInfo(message.data);
break;</p>
</dd>
<dt>case ‘query_completed’:</dt><dd><p>this.updateQueryResults(message.data);
break;</p>
</dd>
<dt>case ‘peer_connected’:</dt><dd><p>this.updatePeerList(message.data);
break;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>updateBlockInfo(blockData) {</dt><dd><p>const blockElement = document.getElementById(‘latest-block’);
blockElement.innerHTML = `</p>
<blockquote>
<div><p>&lt;div&gt;Block #${blockData.index}&lt;/div&gt;
&lt;div&gt;Hash: ${blockData.hash.substring(0, 16)}…&lt;/div&gt;
&lt;div&gt;Triples: ${blockData.triple_count}&lt;/div&gt;
&lt;div&gt;Time: ${new Date(blockData.timestamp).toLocaleTimeString()}&lt;/div&gt;</p>
</div></blockquote>
<p><a href="#id155"><span class="problematic" id="id156">`</span></a>;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>updateQueryResults(queryData) {</dt><dd><p>const resultsElement = document.getElementById(‘query-results’);
resultsElement.innerHTML = `</p>
<blockquote>
<div><p>&lt;div&gt;Query completed with ${queryData.result_count} results&lt;/div&gt;
&lt;div&gt;Execution time: ${queryData.execution_time_ms}ms&lt;/div&gt;</p>
</div></blockquote>
<p><a href="#id157"><span class="problematic" id="id158">`</span></a>;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>updatePeerList(peerData) {</dt><dd><p>const peerElement = document.getElementById(‘peer-count’);
peerElement.textContent = peerData.connected_peers.length;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Initialize dashboard
const dashboard = new ProvChainDashboard();
<a href="#id159"><span class="problematic" id="id160">``</span></a><a href="#id161"><span class="problematic" id="id162">`</span></a></p>
<p><a href="#id163"><span class="problematic" id="id164">``</span></a><a href="#id165"><span class="problematic" id="id166">`</span></a>javascript
class QueryMonitor {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor() {</dt><dd><p>this.ws = new WebSocket(‘ws://localhost:8080/ws?api_key=YOUR_API_KEY’);
this.activeQueries = new Map();
this.setupEventHandlers();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>setupEventHandlers() {</dt><dd><dl class="simple">
<dt>this.ws.onopen = () =&gt; {</dt><dd><p>console.log(‘Query monitor connected’);</p>
</dd>
</dl>
<p>};</p>
<dl class="simple">
<dt>this.ws.onmessage = (event) =&gt; {</dt><dd><p>const message = JSON.parse(event.data);
this.handleMessage(message);</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>executeQuery(sparqlQuery) {</dt><dd><p>const queryId = <cite>query_${Date.now()}</cite>;</p>
<dl class="simple">
<dt>this.activeQueries.set(queryId, {</dt><dd><p>query: sparqlQuery,
startTime: Date.now(),
progress: 0,
resultCount: 0</p>
</dd>
</dl>
<p>});</p>
<dl>
<dt>this.ws.send(JSON.stringify({</dt><dd><p>type: ‘execute_query’,
command: {</p>
<blockquote>
<div><p>query_id: queryId,
sparql_query: sparqlQuery,
stream_results: true</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}));</p>
<p>return queryId;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleMessage(message) {</dt><dd><dl class="simple">
<dt>switch (message.type) {</dt><dd><dl class="simple">
<dt>case ‘query_started’:</dt><dd><p>this.handleQueryStarted(message.data);
break;</p>
</dd>
<dt>case ‘query_progress’:</dt><dd><p>this.handleQueryProgress(message.data);
break;</p>
</dd>
<dt>case ‘query_completed’:</dt><dd><p>this.handleQueryCompleted(message.data);
break;</p>
</dd>
<dt>case ‘query_results’:</dt><dd><p>this.handleQueryResults(message.data);
break;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handleQueryStarted(data) {</dt><dd><p>console.log(<cite>Query ${data.query_id} started</cite>);
this.updateQueryDisplay(data.query_id, ‘started’);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleQueryProgress(data) {</dt><dd><p>const query = this.activeQueries.get(data.query_id);
if (query) {</p>
<blockquote>
<div><p>query.progress = data.progress;
query.resultCount = data.current_result_count;
this.updateQueryDisplay(data.query_id, ‘progress’, query);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleQueryResults(data) {</dt><dd><p>const query = this.activeQueries.get(data.query_id);
if (query) {</p>
<blockquote>
<div><p>query.results = data.results;
this.updateQueryDisplay(data.query_id, ‘results’, query);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleQueryCompleted(data) {</dt><dd><p>const query = this.activeQueries.get(data.query_id);
if (query) {</p>
<blockquote>
<div><p>query.endTime = Date.now();
query.executionTime = query.endTime - query.startTime;
this.activeQueries.delete(data.query_id);
this.updateQueryDisplay(data.query_id, ‘completed’, query);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>updateQueryDisplay(queryId, status, queryData = null) {</dt><dd><p>const element = document.getElementById(<cite>query-${queryId}</cite>);
if (!element) {</p>
<blockquote>
<div><p>this.createQueryElement(queryId);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>switch (status) {</dt><dd><dl>
<dt>case ‘started’:</dt><dd><p>this.updateElement(queryId, ‘Query started…’);
break;</p>
</dd>
<dt>case ‘progress’:</dt><dd><dl class="simple">
<dt>this.updateElement(queryId,</dt><dd><p><cite>Progress: ${queryData.progress}%, Results: ${queryData.resultCount}</cite>);</p>
</dd>
</dl>
<p>break;</p>
</dd>
<dt>case ‘results’:</dt><dd><dl class="simple">
<dt>this.updateElement(queryId,</dt><dd><p><cite>Received ${queryData.results.length} results</cite>);</p>
</dd>
</dl>
<p>break;</p>
</dd>
<dt>case ‘completed’:</dt><dd><dl class="simple">
<dt>this.updateElement(queryId,</dt><dd><p><cite>Completed in ${queryData.executionTime}ms with ${data.result_count} results</cite>);</p>
</dd>
</dl>
<p>break;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>createQueryElement(queryId) {</dt><dd><p>const container = document.getElementById(‘query-monitor’);
const element = document.createElement(‘div’);
element.id = <cite>query-${queryId}</cite>;
element.className = ‘query-item’;
container.appendChild(element);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>updateElement(queryId, text) {</dt><dd><p>const element = document.getElementById(<cite>query-${queryId}</cite>);
if (element) {</p>
<blockquote>
<div><p>element.textContent = text;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Usage
const monitor = new QueryMonitor();</p>
<p>// Execute a query
const queryId = monitor.executeQuery(`</p>
<blockquote>
<div><dl class="simple">
<dt>SELECT ?batch ?product ?farm WHERE {</dt><dd><dl class="simple">
<dt>?batch a :ProductBatch ;</dt><dd><p>:product ?product ;
:originFarm ?farm .</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<section id="id169">
<h3><a href="#id167"><span class="problematic" id="id168">`</span></a>);</h3>
</section>
</section>
<section id="troubleshooting">
<h2>Troubleshooting</h2>
<dl class="simple">
<dt><strong>Connection Refused</strong></dt><dd><ul class="simple">
<li><p>Verify ProvChainOrg server is running</p></li>
<li><p>Check WebSocket URL and port</p></li>
<li><p>Ensure firewall allows WebSocket connections</p></li>
</ul>
</dd>
<dt><strong>Authentication Failed</strong></dt><dd><ul class="simple">
<li><p>Verify API key is correct and valid</p></li>
<li><p>Check API key permissions for WebSocket access</p></li>
<li><p>Ensure authentication token is properly formatted</p></li>
</ul>
</dd>
<dt><strong>Message Loss</strong></dt><dd><ul class="simple">
<li><p>Implement message acknowledgment system</p></li>
<li><p>Add sequence numbers for message ordering</p></li>
<li><p>Implement proper error handling and retransmission</p></li>
</ul>
</dd>
<dt><strong>Performance Issues</strong></dt><dd><ul class="simple">
<li><p>Enable message compression for large data</p></li>
<li><p>Implement message batching</p></li>
<li><p>Use connection pooling for multiple clients</p></li>
</ul>
</dd>
<dt><strong>Memory Leaks</strong></dt><dd><ul class="simple">
<li><p>Clean up event listeners properly</p></li>
<li><p>Cancel subscriptions when disconnecting</p></li>
<li><p>Implement proper garbage collection for message queues</p></li>
</ul>
</dd>
</dl>
<p><strong>Enable Debug Logging</strong>
<a href="#id170"><span class="problematic" id="id171">``</span></a><a href="#id172"><span class="problematic" id="id173">`</span></a>javascript
const ws = new WebSocket(‘ws://localhost:8080/ws?api_key=YOUR_API_KEY&amp;debug=true’);</p>
<dl class="simple">
<dt>ws.onmessage = (event) =&gt; {</dt><dd><p>console.log(‘Raw message:’, event.data);
const message = JSON.parse(event.data);
console.log(‘Parsed message:’, message);</p>
</dd>
</dl>
<section id="id174">
<h3>};</h3>
<p><strong>Monitor Connection State</strong>
<a href="#id175"><span class="problematic" id="id176">``</span></a><a href="#id177"><span class="problematic" id="id178">`</span></a>javascript
class ConnectionMonitor {</p>
<blockquote>
<div><dl class="simple">
<dt>constructor(ws) {</dt><dd><p>this.ws = ws;
this.connectionStates = [];
this.setupMonitoring();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>setupMonitoring() {</dt><dd><dl class="simple">
<dt>this.ws.addEventListener(‘open’, () =&gt; {</dt><dd><p>this.logConnectionState(‘connected’);</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>this.ws.addEventListener(‘close’, (event) =&gt; {</dt><dd><p>this.logConnectionState(‘disconnected’, event);</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>this.ws.addEventListener(‘error’, (error) =&gt; {</dt><dd><p>this.logConnectionState(‘error’, error);</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>logConnectionState(state, event = null) {</dt><dd><dl class="simple">
<dt>const logEntry = {</dt><dd><p>timestamp: new Date().toISOString(),
state: state,
event: event</p>
</dd>
</dl>
<p>};</p>
<p>this.connectionStates.push(logEntry);
console.log(‘Connection state change:’, logEntry);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>getConnectionHistory() {</dt><dd><p>return this.connectionStates;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id179">
<h3>}</h3>
<p><strong>Message Flow Analysis</strong>
<a href="#id180"><span class="problematic" id="id181">``</span></a><a href="#id182"><span class="problematic" id="id183">`</span></a>javascript
class MessageAnalyzer {</p>
<blockquote>
<div><dl>
<dt>constructor() {</dt><dd><dl class="simple">
<dt>this.messageStats = {</dt><dd><p>total: 0,
byType: {},
errors: 0,
averageLatency: 0</p>
</dd>
</dl>
<p>};
this.messageHistory = [];</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>analyzeMessage(message) {</dt><dd><dl class="simple">
<dt>const analysis = {</dt><dd><p>timestamp: Date.now(),
type: message.type,
size: JSON.stringify(message).length,
hasError: !!message.error</p>
</dd>
</dl>
<p>};</p>
<p>this.messageStats.total++;
this.messageStats.byType[message.type] = (this.messageStats.byType[message.type] || 0) + 1;</p>
<dl class="simple">
<dt>if (message.error) {</dt><dd><p>this.messageStats.errors++;</p>
</dd>
</dl>
<p>}</p>
<p>this.messageHistory.push(analysis);
this.updateStatistics();</p>
<p>return analysis;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>updateStatistics() {</dt><dd><dl class="simple">
<dt>if (this.messageHistory.length &gt; 0) {</dt><dd><p>const recentMessages = this.messageHistory.slice(-100);
const totalLatency = recentMessages.reduce((sum, msg) =&gt; sum + (Date.now() - msg.timestamp), 0);
this.messageStats.averageLatency = totalLatency / recentMessages.length;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>getStatistics() {</dt><dd><p>return { …this.messageStats };</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id184">
<h3>}</h3>
</section>
</section>
<section id="best-practices">
<h2>Best Practices</h2>
<ol class="arabic simple">
<li><p><strong>Implement Proper Error Handling</strong>: Handle all WebSocket error scenarios gracefully.</p></li>
<li><p><strong>Use Connection Management</strong>: Implement automatic reconnection with backoff strategies.</p></li>
<li><p><strong>Message Ordering</strong>: Ensure messages are processed in the correct order.</p></li>
<li><p><strong>Resource Management</strong>: Clean up resources properly when disconnecting.</p></li>
<li><p><strong>Security</strong>: Use secure authentication and encryption for sensitive data.</p></li>
<li><p><strong>Performance</strong>: Optimize message handling with batching and compression.</p></li>
<li><p><strong>Monitoring</strong>: Implement logging and monitoring for WebSocket connections.</p></li>
<li><p><strong>Testing</strong>: Test WebSocket connections under various network conditions.</p></li>
<li><p><strong>Documentation</strong>: Document WebSocket API usage and message formats.</p></li>
<li><p><strong>Versioning</strong>: Implement versioning for WebSocket messages to handle API changes.</p></li>
</ol>
</section>
<section id="related-resources">
<h2>Related Resources</h2>
<ul class="simple">
<li><p><strong>WebSocket API Specification</strong>: RFC 6455</p></li>
<li><p><strong>SPARQL 1.1 Protocol</strong>: W3C Recommendation</p></li>
<li><p><strong>Real-time Web Applications</strong>: Best practices and patterns</p></li>
<li><p><strong>WebSocket Security</strong>: Authentication and encryption guidelines</p></li>
<li><p><strong>Performance Optimization</strong>: WebSocket performance tuning</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>